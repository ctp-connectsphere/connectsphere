generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String                    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email                    String                    @unique
  passwordHash             String                    @map("password_hash")
  firstName                String                    @map("first_name")
  lastName                 String                    @map("last_name")
  university               String
  profileImageUrl          String?                   @map("profile_image_url")
  isVerified               Boolean                   @default(false) @map("is_verified")
  isActive                 Boolean                   @default(true) @map("is_active")
  emailVerifiedAt          DateTime?                 @map("email_verified_at")
  lastLoginAt              DateTime?                 @map("last_login_at")
  createdAt                DateTime                  @default(now()) @map("created_at")
  updatedAt                DateTime                  @updatedAt @map("updated_at")
  major                    String?
  settings                 Json?
  accounts                 Account[]
  availability             Availability[]
  connectionsAsRequester   Connection[]              @relation("RequesterConnections")
  connectionsAsTarget      Connection[]              @relation("TargetConnections")
  conversationParticipants ConversationParticipant[]
  groupMembers             GroupMember[]
  matchCache               MatchCache[]
  matchesAsUser1           Match[]                   @relation("User1Matches")
  matchesAsUser2           Match[]                   @relation("User2Matches")
  messages                 Message[]
  sessions                 Session[]
  studySessionParticipants StudySessionParticipant[]
  studySessions            StudySession[]
  topicMatchCache          TopicMatchCache[]
  userCourses              UserCourse[]
  userProfile              UserProfile?
  user_sessions            user_sessions[]
  userTopics               UserTopic[]

  @@map("users")
}

model Account {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId            String   @map("user_id") @db.Uuid
  type              String
  provider          String
  providerAccountId String   @map("provider_account_id")
  refreshToken      String?  @map("refresh_token")
  accessToken       String?  @map("access_token")
  expiresAt         Int?     @map("expires_at")
  tokenType         String?  @map("token_type")
  scope             String?  @map("scope")
  idToken           String?  @map("id_token")
  sessionState      String?  @map("session_state")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id") @db.Uuid
  expires      DateTime
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model PasswordReset {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email     String    @unique
  token     String    @unique
  expiresAt DateTime  @map("expires_at")
  createdAt DateTime  @default(now()) @map("created_at")
  usedAt    DateTime? @map("used_at")

  @@map("password_resets")
}

model UserProfile {
  id                  String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId              String   @unique @map("user_id") @db.Uuid
  preferredLocation   String?  @map("preferred_location")
  studyStyle          String?  @map("study_style")
  studyPace           String?  @map("study_pace")
  bio                 String?
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")
  onboardingCompleted Boolean  @default(false) @map("onboarding_completed")
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model Availability {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  dayOfWeek Int      @map("day_of_week")
  startTime String   @map("start_time")
  endTime   String   @map("end_time")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("availability")
}

model University {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String   @unique
  domain    String   @unique
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  courses   Course[]

  @@map("universities")
}

model Course {
  id            String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  code          String
  section       String
  semester      String
  instructor    String?
  schedule      String?
  universityId  String         @map("university_id") @db.Uuid
  isActive      Boolean        @default(true) @map("is_active")
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")
  // room          String?  // Temporarily commented out for production seeding
  connections   Connection[]
  university    University     @relation(fields: [universityId], references: [id])
  groups        Group[]
  matchCache    MatchCache[]
  studySessions StudySession[]
  userCourses   UserCourse[]

  @@unique([code, section, semester, universityId])
  @@map("courses")
}

model UserCourse {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  courseId   String   @map("course_id") @db.Uuid
  enrolledAt DateTime @default(now()) @map("enrolled_at")
  isActive   Boolean  @default(true) @map("is_active")
  // status     String   @default("Enrolled")  // Temporarily commented out for production
  course     Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
  @@map("user_courses")
}

model Topic {
  id              String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name            String
  category        String
  description     String?
  icon            String?
  isActive        Boolean           @default(true) @map("is_active")
  createdAt       DateTime          @default(now()) @map("created_at")
  updatedAt       DateTime          @updatedAt @map("updated_at")
  connections     Connection[]
  topicMatchCache TopicMatchCache[]
  userTopics      UserTopic[]

  @@unique([name, category])
  @@map("topics")
}

model UserTopic {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  topicId     String   @map("topic_id") @db.Uuid
  proficiency String?
  interest    String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  topic       Topic    @relation(fields: [topicId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, topicId])
  @@map("user_topics")
}

model Connection {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  requesterId    String    @map("requester_id") @db.Uuid
  targetId       String    @map("target_id") @db.Uuid
  courseId       String?   @map("course_id") @db.Uuid
  status         String    @default("pending")
  initialMessage String?   @map("initial_message")
  requestedAt    DateTime  @default(now()) @map("requested_at")
  respondedAt    DateTime? @map("responded_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")
  topicId        String?   @map("topic_id") @db.Uuid
  course         Course?   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  requester      User      @relation("RequesterConnections", fields: [requesterId], references: [id], onDelete: Cascade)
  target         User      @relation("TargetConnections", fields: [targetId], references: [id], onDelete: Cascade)
  topic          Topic?    @relation(fields: [topicId], references: [id], onDelete: Cascade)
  messages       Message[]

  @@map("connections")
}

model Match {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId1    String   @map("user_id_1") @db.Uuid
  userId2    String   @map("user_id_2") @db.Uuid
  status     String   @default("Pending")
  matchScore Int?     @map("match_score")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  user1      User     @relation("User1Matches", fields: [userId1], references: [id], onDelete: Cascade)
  user2      User     @relation("User2Matches", fields: [userId2], references: [id], onDelete: Cascade)

  @@unique([userId1, userId2])
  @@map("matches")
}

model MatchCache {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId       String   @map("user_id") @db.Uuid
  courseId     String   @map("course_id") @db.Uuid
  matchResults Json     @map("match_results")
  calculatedAt DateTime @default(now()) @map("calculated_at")
  expiresAt    DateTime @map("expires_at")
  course       Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
  @@map("match_cache")
}

model TopicMatchCache {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId       String   @map("user_id") @db.Uuid
  topicId      String   @map("topic_id") @db.Uuid
  matchResults Json     @map("match_results")
  calculatedAt DateTime @default(now()) @map("calculated_at")
  expiresAt    DateTime @map("expires_at")
  topic        Topic    @relation(fields: [topicId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, topicId])
  @@map("topic_match_cache")
}

model Conversation {
  id           String                    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type         String                    @default("Direct")
  groupId      String?                   @map("group_id") @db.Uuid
  createdAt    DateTime                  @default(now()) @map("created_at")
  updatedAt    DateTime                  @updatedAt @map("updated_at")
  participants ConversationParticipant[]
  group        Group?                    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  messages     Message[]

  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId String       @map("conversation_id") @db.Uuid
  userId         String       @map("user_id") @db.Uuid
  joinedAt       DateTime     @default(now()) @map("joined_at")
  lastReadAt     DateTime?    @map("last_read_at")
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Message {
  id             String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  connectionId   String?       @map("connection_id") @db.Uuid
  senderId       String        @map("sender_id") @db.Uuid
  content        String
  messageType    String        @default("text") @map("message_type")
  isRead         Boolean       @default(false) @map("is_read")
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")
  conversationId String?       @map("conversation_id") @db.Uuid
  metadata       Json?
  connection     Connection?   @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User          @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Group {
  id            String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  description   String?
  courseId      String?        @map("course_id") @db.Uuid
  maxMembers    Int            @default(6) @map("max_members")
  vibe          String?
  tags          Json?
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")
  conversations Conversation[]
  members       GroupMember[]
  course        Course?        @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@map("groups")
}

model GroupMember {
  id       String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  groupId  String   @map("group_id") @db.Uuid
  userId   String   @map("user_id") @db.Uuid
  role     String   @default("Member")
  joinedAt DateTime @default(now()) @map("joined_at")
  group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@map("group_members")
}

model StudySession {
  id           String                    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  organizerId  String                    @map("organizer_id") @db.Uuid
  courseId     String?                   @map("course_id") @db.Uuid
  title        String?
  startTime    DateTime                  @map("start_time")
  endTime      DateTime?                 @map("end_time")
  location     String?
  status       String                    @default("Proposed")
  createdAt    DateTime                  @default(now()) @map("created_at")
  updatedAt    DateTime                  @updatedAt @map("updated_at")
  participants StudySessionParticipant[]
  course       Course?                   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  organizer    User                      @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@map("study_sessions")
}

model StudySessionParticipant {
  id        String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId String       @map("session_id") @db.Uuid
  userId    String       @map("user_id") @db.Uuid
  status    String       @default("Pending")
  joinedAt  DateTime?    @map("joined_at")
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@map("study_session_participants")
}

model user_sessions {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String   @db.Uuid
  refresh_token String   @unique
  device_info   String?
  ip_address    String?  @db.Inet
  expires_at    DateTime
  created_at    DateTime @default(now())
  updated_at    DateTime
  users         User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
}
