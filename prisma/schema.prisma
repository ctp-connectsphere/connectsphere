generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

generator prismaClient {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model accounts {
  id                  String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id             String   @db.Uuid
  type                String
  provider            String
  provider_account_id String
  refresh_token       String?
  access_token        String?
  expires_at          Int?
  token_type          String?
  scope               String?
  id_token            String?
  session_state       String?
  created_at          DateTime @default(now())
  updated_at          DateTime
  users               users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([provider, provider_account_id])
}

model availability {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  day_of_week Int
  start_time  String
  end_time    String
  created_at  DateTime @default(now())
  updated_at  DateTime
  users       users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model connections {
  id                                    String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  requester_id                          String     @db.Uuid
  target_id                             String     @db.Uuid
  course_id                             String?    @db.Uuid
  status                                String     @default("pending")
  initial_message                       String?
  requested_at                          DateTime   @default(now())
  responded_at                          DateTime?
  created_at                            DateTime   @default(now())
  updated_at                            DateTime
  topic_id                              String?    @db.Uuid
  courses                               courses?   @relation(fields: [course_id], references: [id], onDelete: Cascade)
  users_connections_requester_idTousers users      @relation("connections_requester_idTousers", fields: [requester_id], references: [id], onDelete: Cascade)
  users_connections_target_idTousers    users      @relation("connections_target_idTousers", fields: [target_id], references: [id], onDelete: Cascade)
  topics                                topics?    @relation(fields: [topic_id], references: [id], onDelete: Cascade)
  messages                              messages[]
}

model conversation_participants {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversation_id String        @db.Uuid
  user_id         String        @db.Uuid
  joined_at       DateTime      @default(now())
  last_read_at    DateTime?
  conversations   conversations @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  users           users         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([conversation_id, user_id])
}

model conversations {
  id                        String                      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type                      String                      @default("Direct")
  group_id                  String?                     @db.Uuid
  created_at                DateTime                    @default(now())
  updated_at                DateTime
  conversation_participants conversation_participants[]
  groups                    groups?                     @relation(fields: [group_id], references: [id], onDelete: Cascade)
  messages                  messages[]
}

model courses {
  id             String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name           String
  code           String
  section        String
  semester       String
  instructor     String?
  schedule       String?
  university_id  String           @db.Uuid
  is_active      Boolean          @default(true)
  created_at     DateTime         @default(now())
  updated_at     DateTime
  room           String?
  connections    connections[]
  universities   universities     @relation(fields: [university_id], references: [id])
  groups         groups[]
  match_cache    match_cache[]
  study_sessions study_sessions[]
  user_courses   user_courses[]

  @@unique([code, section, semester, university_id])
}

model group_members {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  group_id  String   @db.Uuid
  user_id   String   @db.Uuid
  role      String   @default("Member")
  joined_at DateTime @default(now())
  groups    groups   @relation(fields: [group_id], references: [id], onDelete: Cascade)
  users     users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([group_id, user_id])
}

model groups {
  id            String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  description   String?
  course_id     String?         @db.Uuid
  max_members   Int             @default(6)
  vibe          String?
  tags          Json?
  created_at    DateTime        @default(now())
  updated_at    DateTime
  conversations conversations[]
  group_members group_members[]
  courses       courses?        @relation(fields: [course_id], references: [id], onDelete: Cascade)
}

model match_cache {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String   @db.Uuid
  course_id     String   @db.Uuid
  match_results Json
  calculated_at DateTime @default(now())
  expires_at    DateTime
  courses       courses  @relation(fields: [course_id], references: [id], onDelete: Cascade)
  users         users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, course_id])
}

model matches {
  id                             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id_1                      String   @db.Uuid
  user_id_2                      String   @db.Uuid
  status                         String   @default("Pending")
  match_score                    Int?
  created_at                     DateTime @default(now())
  updated_at                     DateTime
  users_matches_user_id_1Tousers users    @relation("matches_user_id_1Tousers", fields: [user_id_1], references: [id], onDelete: Cascade)
  users_matches_user_id_2Tousers users    @relation("matches_user_id_2Tousers", fields: [user_id_2], references: [id], onDelete: Cascade)

  @@unique([user_id_1, user_id_2])
}

model messages {
  id              String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  connection_id   String?        @db.Uuid
  sender_id       String         @db.Uuid
  content         String
  message_type    String         @default("text")
  is_read         Boolean        @default(false)
  created_at      DateTime       @default(now())
  updated_at      DateTime
  conversation_id String?        @db.Uuid
  metadata        Json?
  connections     connections?   @relation(fields: [connection_id], references: [id], onDelete: Cascade)
  conversations   conversations? @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  users           users          @relation(fields: [sender_id], references: [id], onDelete: Cascade)
}

model password_resets {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email      String    @unique
  token      String    @unique
  expires_at DateTime
  created_at DateTime  @default(now())
  used_at    DateTime?
}

model sessions {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_token String   @unique
  user_id       String   @db.Uuid
  expires       DateTime
  created_at    DateTime @default(now())
  updated_at    DateTime
  users         users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model study_session_participants {
  id             String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id     String         @db.Uuid
  user_id        String         @db.Uuid
  status         String         @default("Pending")
  joined_at      DateTime?
  study_sessions study_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade)
  users          users          @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([session_id, user_id])
}

model study_sessions {
  id                         String                       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  organizer_id               String                       @db.Uuid
  course_id                  String?                      @db.Uuid
  title                      String?
  start_time                 DateTime
  end_time                   DateTime?
  location                   String?
  status                     String                       @default("Proposed")
  created_at                 DateTime                     @default(now())
  updated_at                 DateTime
  study_session_participants study_session_participants[]
  courses                    courses?                     @relation(fields: [course_id], references: [id], onDelete: Cascade)
  users                      users                        @relation(fields: [organizer_id], references: [id], onDelete: Cascade)
}

model topic_match_cache {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String   @db.Uuid
  topic_id      String   @db.Uuid
  match_results Json
  calculated_at DateTime @default(now())
  expires_at    DateTime
  topics        topics   @relation(fields: [topic_id], references: [id], onDelete: Cascade)
  users         users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, topic_id])
}

model topics {
  id                String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name              String
  category          String
  description       String?
  icon              String?
  is_active         Boolean             @default(true)
  created_at        DateTime            @default(now())
  updated_at        DateTime
  connections       connections[]
  topic_match_cache topic_match_cache[]
  user_topics       user_topics[]

  @@unique([name, category])
}

model universities {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name       String    @unique
  domain     String    @unique
  is_active  Boolean   @default(true)
  created_at DateTime  @default(now())
  courses    courses[]
}

model user_courses {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  course_id   String   @db.Uuid
  enrolled_at DateTime @default(now())
  is_active   Boolean  @default(true)
  status      String   @default("Enrolled")
  courses     courses  @relation(fields: [course_id], references: [id], onDelete: Cascade)
  users       users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, course_id])
}

model user_profiles {
  id                   String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id              String   @unique @db.Uuid
  preferred_location   String?
  study_style          String?
  study_pace           String?
  bio                  String?
  created_at           DateTime @default(now())
  updated_at           DateTime
  onboarding_completed Boolean  @default(false)
  users                users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model user_sessions {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String   @db.Uuid
  refresh_token String   @unique
  device_info   String?
  ip_address    String?  @db.Inet
  expires_at    DateTime
  created_at    DateTime @default(now())
  updated_at    DateTime
  users         users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model user_topics {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  topic_id    String   @db.Uuid
  proficiency String?
  interest    String?
  created_at  DateTime @default(now())
  updated_at  DateTime
  topics      topics   @relation(fields: [topic_id], references: [id], onDelete: Cascade)
  users       users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, topic_id])
}

model users {
  id                                          String                       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email                                       String                       @unique
  password_hash                               String
  first_name                                  String
  last_name                                   String
  university                                  String
  profile_image_url                           String?
  is_verified                                 Boolean                      @default(false)
  is_active                                   Boolean                      @default(true)
  email_verified_at                           DateTime?
  last_login_at                               DateTime?
  created_at                                  DateTime                     @default(now())
  updated_at                                  DateTime
  major                                       String?
  settings                                    Json?
  accounts                                    accounts[]
  availability                                availability[]
  connections_connections_requester_idTousers connections[]                @relation("connections_requester_idTousers")
  connections_connections_target_idTousers    connections[]                @relation("connections_target_idTousers")
  conversation_participants                   conversation_participants[]
  group_members                               group_members[]
  match_cache                                 match_cache[]
  matches_matches_user_id_1Tousers            matches[]                    @relation("matches_user_id_1Tousers")
  matches_matches_user_id_2Tousers            matches[]                    @relation("matches_user_id_2Tousers")
  messages                                    messages[]
  sessions                                    sessions[]
  study_session_participants                  study_session_participants[]
  study_sessions                              study_sessions[]
  topic_match_cache                           topic_match_cache[]
  user_courses                                user_courses[]
  user_profiles                               user_profiles?
  user_sessions                               user_sessions[]
  user_topics                                 user_topics[]
}

model verification_tokens {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  identifier String
  token      String   @unique
  expires    DateTime
  created_at DateTime @default(now())
  updated_at DateTime

  @@unique([identifier, token])
}
